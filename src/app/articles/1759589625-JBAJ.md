---
id: 1759589625-JBAJ
aliases: []
tags: []
datePosted: "2025-10-04"
dateUpdated: "2025-10-04"
---

# Coding Challenge: Writing my own wc

Recently I attempted to write my own wc tool according to [this article](https://codingchallenges.fyi/challenges/challenge-wc). The main goal was to familiarise myself with the `perf` tool. Today I will write to share about my thoughts.

## Initial Idea

I started off with a naive implementation of wc, for each flag passed in we will scan the file one time and produce an output.

```cpp
#include <fstream>
#include <ios>
#include <iterator>
#include <string>
#include <iostream>

int main(int argc, char** argv) {
  int flag_mask = 0;
  for(int i = 0; i < argc; i++) {
    std::string str_cmp = argv[i];
    if (str_cmp == "-c") flag_mask |= 1 << 0;
    if (str_cmp == "-l") flag_mask |= 1 << 1;
    if (str_cmp == "-w") flag_mask |= 1 << 2;
    if (str_cmp == "-m") flag_mask |= 1 << 3;
  }

  // default args
  if (flag_mask == 0) flag_mask |= (1 << 3) - 1;

  std::string filename = argv[argc - 1];
  std::ifstream infile(filename, std::ios::binary);
  
  if ((flag_mask >> 0) & 1) {
    infile.seekg(0);
    int res = 0;
    std::string line;
    while (std::getline(infile, line)) {
      res++;
    }
    std::cout << res << " ";
  }

  if ((flag_mask >> 1) & 1) {
    infile.clear();
    infile.seekg(0, std::ios::beg);

    int res = 0;
    std::string word;
    while (infile >> word) {
      res++;
    }
    std::cout << res << " ";
  }

  if ((flag_mask >> 2) & 1) {
    infile.clear();
    infile.seekg(0, std::ios::end);
    int res = infile.tellg();
    std::cout << res << " ";
  }

  if ((flag_mask >> 3) & 1) {
    std::istreambuf_iterator<char> it(infile), end;
    int res = 0;

    for(; it != end; it++) {
      unsigned char c = static_cast<unsigned char>(*it);
      if ((c & 0xC0) != 0x80) res++;
    }

    std::cout << res << " ";
  }

  std::cout << filename << std::endl;
  return 0;
};
```

Of course this a really inefficient implmeentation for many reasons, but lets use perf to take some measurements

```
 Performance counter stats for './ccwc-old test.txt' (50 runs):

              3.49 msec task-clock:u                     #    0.915 CPUs utilized               ( +-  4.15% )
                 0      context-switches:u               #    0.000 /sec
                 0      cpu-migrations:u                 #    0.000 /sec
               133      page-faults:u                    #   38.109 K/sec                       ( +-  0.12% )
        20,737,107      instructions:u                   #    2.11  insn per cycle              ( +-  0.00% )
         9,836,041      cycles:u                         #    2.818 GHz                         ( +-  0.29% )
         4,383,614      branches:u                       #    1.256 G/sec                       ( +-  0.00% )
            89,777      branch-misses:u                  #    2.05% of all branches             ( +-  0.11% )
                        TopdownL1                 #     12.8 %  tma_backend_bound
                                                  #     33.6 %  tma_bad_speculation
                                                  #     12.1 %  tma_frontend_bound
                                                  #     41.5 %  tma_retiring             ( +-  0.28% )

          0.003812 +- 0.000159 seconds time elapsed  ( +-  4.17% )
```

Looking at the flamegraph, it seems that a majority of the time its spent in `std::basic_istream`

![naive_flamegraph.png](assets/imgs/naive_flamegraph.png)


## What is std::basic_istream?

From ChatGPT, at a high level `std::basic_istream` does the following steps for each call:
- A sentry object is constructed — flushes tied output streams if necessary.
- If std::skipws flag is set, it skips whitespace using locale-aware isspace().
- It possibly calls the buffer’s uflow() (→ virtual call) to get next character(s).
- Converts from narrow/wide depending on stream type and locale.
- Parses the input value according to format rules.
- Handles numeric base (dec, hex, oct).
- Sets stream state bits (eofbit, failbit, badbit).
- Calls locale facets (num_get, etc.) to perform conversions.
- Destroys sentry and returns a reference to *this.

I plan to investigate what `std::basic_istream` actually does in the future, stay tuned

## What does this mean?

When we discuss performance, we mainly talk about 3 things:
1. CPU Bound
2. I/O Bound
3. Memory Bound

From our flamegraph, we see that a majority of time is spent on `std::basic_istream`, this means that our function is **CPU bound**.

## How do we improve this

```cpp
#include <cstdio>
#include <string>
#include <iostream>
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char** argv) {
  int flag_mask = 0;
  for(int i = 0; i < argc; i++) {
    std::string str_cmp = argv[i];
    if (str_cmp == "-c") flag_mask |= 1 << 0; // lines
    if (str_cmp == "-l") flag_mask |= 1 << 1; // words
    if (str_cmp == "-w") flag_mask |= 1 << 2; // bytes
    if (str_cmp == "-m") flag_mask |= 1 << 3; // chars
  }

  // default args
  if (flag_mask == 0) flag_mask |= (1 << 3) - 1;

  const char* filename = argv[argc - 1];
  int fd = open(filename, O_RDONLY);
  if (fd < 0) {
    perror("open");
    return 1;
  }

  const size_t BUFFER_SIZE = 1 << 16;
  char buffer[BUFFER_SIZE];

  size_t line_count = 0;
  size_t word_count = 0;
  size_t byte_count = 0;
  size_t char_count = 0;

  bool in_word = false;
  ssize_t n = 0;
  while ((n = read(fd, buffer, BUFFER_SIZE)) > 0) {
    byte_count += n;
    
    for (ssize_t i = 0; i < n; i++) {
      unsigned char ch = buffer[i];

      if (flag_mask & 1 && ch == '\n') line_count++;

      if ((flag_mask >> 1) & 1) {
        if (ch == ' ' || ch == '\n' || ch == '\t') {
          if (in_word) {
            word_count++;
            in_word = false;
          }
        } else {
          in_word = true;
        }
      }

      if ((flag_mask >> 3) & 1) {
        if ((ch & 0xC0) != 0x80) char_count++;
      }
    }
  }

  if ((flag_mask >> 1) & 1) word_count++;

  close(fd);

  if ((flag_mask >> 0) & 1) std::cout << line_count << " ";
  if ((flag_mask >> 1) & 1) std::cout << word_count << " ";
  if ((flag_mask >> 2) & 1) std::cout << byte_count << " ";
  if ((flag_mask >> 3) & 1) std::cout << char_count << " ";

  std::cout << filename << std::endl;
  return 0;
};
```
this implmentation performs slightly better than the previous implmentation because we don't iterate over the file for every flag, furthermore we dont rely on `std::basic_istream` anymore, instead relying on the syscall `read()`, removing any extra overhead.

```
 Performance counter stats for './ccwc test.txt' (50 runs):

              1.76 msec task-clock:u                     #    0.866 CPUs utilized               ( +-  0.81% )
                 0      context-switches:u               #    0.000 /sec
                 0      cpu-migrations:u                 #    0.000 /sec
               133      page-faults:u                    #   75.368 K/sec                       ( +-  0.11% )
         9,030,349      instructions:u                   #    1.74  insn per cycle              ( +-  0.00% )
         5,192,363      cycles:u                         #    2.942 GHz                         ( +-  0.56% )
         2,484,672      branches:u                       #    1.408 G/sec                       ( +-  0.00% )
            87,431      branch-misses:u                  #    3.52% of all branches             ( +-  0.15% )
                        TopdownL1                 #     13.6 %  tma_backend_bound
                                                  #     35.8 %  tma_bad_speculation
                                                  #     22.5 %  tma_frontend_bound
                                                  #     28.1 %  tma_retiring             ( +-  0.33% )

         0.0020370 +- 0.0000193 seconds time elapsed  ( +-  0.95% )
```


However we have still some way to go before we can even reach `wc`

```

 Performance counter stats for 'wc test.txt' (50 runs):

              1.50 msec task-clock:u                     #    0.846 CPUs utilized               ( +-  2.17% )
                 0      context-switches:u               #    0.000 /sec
                 0      cpu-migrations:u                 #    0.000 /sec
               129      page-faults:u                    #   85.978 K/sec                       ( +-  0.10% )
        10,127,679      instructions:u                   #    2.28  insn per cycle              ( +-  0.00% )
         4,435,987      cycles:u                         #    2.957 GHz                         ( +-  0.31% )
         1,573,078      branches:u                       #    1.048 G/sec                       ( +-  0.00% )
            73,744      branch-misses:u                  #    4.69% of all branches             ( +-  0.07% )
                        TopdownL1                 #      7.8 %  tma_backend_bound
                                                  #     34.8 %  tma_bad_speculation
                                                  #     14.8 %  tma_frontend_bound
                                                  #     42.6 %  tma_retiring             ( +-  0.20% )

         0.0017725 +- 0.0000410 seconds time elapsed  ( +-  2.31% )
```


